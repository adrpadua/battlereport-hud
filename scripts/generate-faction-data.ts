import { existsSync, mkdirSync, writeFileSync, readdirSync, unlinkSync, statSync } from 'fs';
import { join } from 'path';
import { fetchAllCatalogues } from './bsdata-fetcher';
import { parseCatalogue, extractFactionAliases } from './bsdata-parser';
import type { FactionIndex } from '../packages/extension/src/types/bsdata';

const OUTPUT_DIR = join(process.cwd(), 'packages/extension/src/data/generated');

async function main() {
  console.log('üîß Generating faction data from BSData...\n');

  // Ensure output directory exists
  if (!existsSync(OUTPUT_DIR)) {
    mkdirSync(OUTPUT_DIR, { recursive: true });
  } else {
    // Clean existing generated files (skip directories like aliases/)
    const existingFiles = readdirSync(OUTPUT_DIR);
    for (const file of existingFiles) {
      const filePath = join(OUTPUT_DIR, file);
      if (statSync(filePath).isFile()) {
        unlinkSync(filePath);
      }
    }
  }

  // Fetch all catalogues
  const catalogues = await fetchAllCatalogues();
  console.log(`\nüì¶ Parsing ${catalogues.length} catalogues...\n`);

  const factionIndex: FactionIndex = { factions: [] };
  const importStatements: string[] = [];
  const exportStatements: string[] = [];
  const loaderFunctions: string[] = [];

  for (const { factionId, filename: originalFilename, content: xmlContent } of catalogues) {
    try {
      const faction = parseCatalogue(xmlContent, factionId, originalFilename);

      // Skip factions with no units (probably library files or empty catalogues)
      if (faction.units.length === 0) {
        console.log(`  ‚è≠Ô∏è  Skipping ${faction.name} (no units found)`);
        continue;
      }

      // Write faction JSON file
      const outputFilename = `${factionId}.json`;
      const filepath = join(OUTPUT_DIR, outputFilename);
      writeFileSync(filepath, JSON.stringify(faction, null, 2));

      console.log(`  ‚úÖ ${faction.name}: ${faction.units.length} units`);

      // Add to index
      const aliases = extractFactionAliases(faction.name, faction.id);
      factionIndex.factions.push({
        id: faction.id,
        name: faction.name,
        aliases,
        unitCount: faction.units.length,
      });

      // Generate loader function name
      const varName = factionId.replace(/-/g, '_');
      loaderFunctions.push(`
export async function load_${varName}(): Promise<FactionData> {
  const data = await import('./${outputFilename}');
  return data.default as FactionData;
}`);

    } catch (error) {
      console.warn(`  ‚ö†Ô∏è  Failed to parse ${factionId}:`, error instanceof Error ? error.message : error);
    }
  }

  // Sort factions alphabetically
  factionIndex.factions.sort((a, b) => a.name.localeCompare(b.name));

  // Write index file with lazy loaders
  const indexContent = `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by scripts/generate-faction-data.ts

import type { FactionData, FactionIndex } from '@/types/bsdata';

export const factionIndex: FactionIndex = ${JSON.stringify(factionIndex, null, 2)};

export type FactionId = ${factionIndex.factions.map(f => `'${f.id}'`).join(' | ') || 'string'};

// Lazy loaders for each faction
${loaderFunctions.join('\n')}

// Dynamic loader by faction ID
export async function loadFactionById(factionId: string): Promise<FactionData | null> {
  switch (factionId) {
${factionIndex.factions.map(f => {
  const varName = f.id.replace(/-/g, '_');
  return `    case '${f.id}': return load_${varName}();`;
}).join('\n')}
    default:
      console.warn(\`Unknown faction ID: \${factionId}\`);
      return null;
  }
}

// Find faction by name or alias
export function findFactionByName(name: string): typeof factionIndex.factions[number] | null {
  const lowerName = name.toLowerCase().trim();

  for (const faction of factionIndex.factions) {
    if (faction.name.toLowerCase() === lowerName) {
      return faction;
    }
    if (faction.aliases.some(alias => alias === lowerName)) {
      return faction;
    }
  }

  // Fuzzy match on aliases containing the name
  for (const faction of factionIndex.factions) {
    if (faction.aliases.some(alias => alias.includes(lowerName) || lowerName.includes(alias))) {
      return faction;
    }
  }

  return null;
}
`;

  writeFileSync(join(OUTPUT_DIR, 'index.ts'), indexContent);

  console.log(`\n‚ú® Generated data for ${factionIndex.factions.length} factions`);
  console.log(`üìÅ Output directory: ${OUTPUT_DIR}`);
}

main().catch((error) => {
  console.error('‚ùå Generation failed:', error);
  process.exit(1);
});
